/*  Pawn compiler - Peephole optimizer "sequences" strings (plain
 *                   and compressed formats)
 *
 *  Copyright (c) ITB CompuPhase, 2000-2006
 *
 *  This software is provided "as-is", without any express or implied warranty.
 *  In no event will the authors be held liable for any damages arising from
 *  the use of this software.
 *
 *  Permission is granted to anyone to use this software for any purpose,
 *  including commercial applications, and to alter it and redistribute it
 *  freely, subject to the following restrictions:
 *
 *  1.  The origin of this software must not be misrepresented; you must not
 *      claim that you wrote the original software. If you use this software in
 *      a product, an acknowledgment in the product documentation would be
 *      appreciated but is not required.
 *  2.  Altered source versions must be plainly marked as such, and must not be
 *      misrepresented as being the original software.
 *  3.  This notice may not be removed or altered from any source distribution.
 *
 *  Version: $Id: sc7.sch 3577 2006-06-02 16:22:52Z thiadmer $
 */

SC_FUNC int strexpand(char *dest, unsigned char *source, int maxlen, unsigned char pairtable[128][2]);

#define SCPACK_TERMINATOR ,     /* end each section with a comma */

#define SCPACK_TABLE sequences_table
/*-*SCPACK start of pair table, do not change or remove this line */
unsigned char sequences_table[][2] = {
  {49,33}, {37,128}, {32,129}, {32,37}, {114,105}, {112,132}, {46,133}, {97,100}, {46,97}, {136,108}, {137,116}, {115,104}, {111,135}, {117,139}, {112,141}, {108,140},
  {131,50}, {144,33}, {46,115}, {138,33}, {59,36}, {134,130}, {143,146}, {115,116}, {134,145}, {110,151}, {111,153}, {99,154}, {112,147}, {135,100}, {134,33}, {114,33},
  {111,156}, {112,160}, {46,99}, {138,130}, {142,158}, {131,51}, {150,152}, {112,33}, {120,167}, {101,168}, {148,169}, {97,159}, {112,171}, {148,172}, {165,33}, {173,142},
  {122,101}, {176,114}, {101,113}, {110,100}, {149,164}, {157,114}, {33,161}, {131,49}, {103,33}, {157,33}, {104,184}, {99,186}, {120,187}, {98,111}, {118,101}, {111,190},
  {109,191}, {130,170}, {131,52}, {106,177}, {138,145}, {180,166}, {192,147}, {108,162}, {163,166}, {143,149}, {115,174}, {117,179}, {139,199}, {203,202}, {189,205}, {105,100},
  {115,103}, {115,108}, {207,120}, {195,130}, {46,135}, {178,33}, {212,114}, {204,134}, {155,149}, {142,162}, {183,145}, {150,149}, {143,152}, {194,33}, {130,175}, {97,179},
  {177,111}, {182,185}, {143,46}, {183,144}, {155,152}, {145,175}, {114,101}, {230,102}, {108,231}, {101,115}, {233,115}, {114,116}, {142,147}, {105,33}, {155,163}, {178,130},
  {215,32}, {240,50}, {143,196}, {155,197}, {181,197}, {181,200}, {108,210}, {46,98}, {241,225}, {208,235}, {209,234}, {224,158}, {143,163}, {150,163}, {155,200}
};
/*-*SCPACK end of pair table, do not change or remove this line */

#define seqsize(o,p)    (opcodes(o)+opargs(p))
typedef struct {
  char *find;
  char *replace;
  int savesize;         /* number of bytes saved (in bytecode) */
} SEQUENCE;
static SEQUENCE sequences_cmp[] = {
  /* A very common sequence in four varieties
   *    load.s.pri n1           load.s.pri n2
   *    push.pri                load.s.alt n1
   *    load.s.pri n2           -
   *    pop.alt                 -
   *    --------------------------------------
   *    load.pri n1             load.s.pri n2
   *    push.pri                load.alt n1
   *    load.s.pri n2           -
   *    pop.alt                 -
   *    --------------------------------------
   *    load.s.pri n1           load.pri n2
   *    push.pri                load.s.alt n1
   *    load.pri n2             -
   *    pop.alt                 -
   *    --------------------------------------
   *    load.pri n1             load.pri n2
   *    push.pri                load.alt n1
   *    load.pri n2             -
   *    pop.alt                 -
   */
  {
    #ifdef SCPACK
      "load.s.pri %1!push.pri!load.s.pri %2!pop.alt!",
      "load.s.pri %2!load.s.alt %1!",
    #else
      "\226\305\241",
      "\246\375",
    #endif
    seqsize(4,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "load.pri %1!push.pri!load.s.pri %2!pop.alt!",
      "load.s.pri %2!load.alt %1!",
    #else
      "\217\305\241",
      "\246\374",
    #endif
    seqsize(4,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!push.pri!load.pri %2!pop.alt!",
      "load.pri %2!load.s.alt %1!",
    #else
      "\226\264\334\241",
      "\334\375",
    #endif
    seqsize(4,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "load.pri %1!push.pri!load.pri %2!pop.alt!",
      "load.pri %2!load.alt %1!",
    #else
      "\217\264\334\241",
      "\334\374",
    #endif
    seqsize(4,2) - seqsize(2,2)
  },
  /* (#1#) The above also occurs with "addr.pri" (array
   * indexing) as the first line; so that adds 2 cases.
   */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!pop.alt!",
      "addr.alt %1!load.s.pri %2!",
    #else
      "\364\241",
      "\365",
    #endif
    seqsize(4,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.pri %2!pop.alt!",
      "addr.alt %1!load.pri %2!",
    #else
      "\265\264\334\241",
      "\265\243\334",
    #endif
    seqsize(4,2) - seqsize(2,2)
  },
  /* And the same sequence with const.pri as either the first
   * or the second load instruction: four more cases.
   */
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!pop.alt!",
      "load.s.pri %2!const.alt %1!",
    #else
      "\363\241",
      "\246\356",
    #endif
    seqsize(4,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.pri %2!pop.alt!",
      "load.pri %2!const.alt %1!",
    #else
      "\233\264\334\241",
      "\334\356",
    #endif
    seqsize(4,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!push.pri!const.pri %2!pop.alt!",
      "const.pri %2!load.s.alt %1!",
    #else
      "\226\264\344\241",
      "\344\375",
    #endif
    seqsize(4,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "load.pri %1!push.pri!const.pri %2!pop.alt!",
      "const.pri %2!load.alt %1!",
    #else
      "\217\264\344\241",
      "\344\374",
    #endif
    seqsize(4,2) - seqsize(2,2)
  },
  /* The same as above, but now with "addr.pri" (array
   * indexing) on the first line and const.pri on
   * the second.
   */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!const.pri %2!pop.alt!",
      "addr.alt %1!const.pri %2!",
    #else
      "\265\264\344\241",
      "\265\243\344",
    #endif
    seqsize(4,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!zero.pri!pop.alt!",
      "addr.alt %1!zero.pri!",
    #else
      "\265\264\373\241",
      "\265\243\373",
    #endif
    seqsize(4,1) - seqsize(2,1)
  },
  /* ??? add references */
  /* Chained relational operators can contain sequences like:
   *    move.pri                load.s.pri n1
   *    push.pri                -
   *    load.s.pri n1           -
   *    pop.alt                 -
   * The above also accurs for "load.pri" and for "const.pri",
   * so add another two cases.
   */
  {
    #ifdef SCPACK
      "move.pri!push.pri!load.s.pri %1!pop.alt!",
      "load.s.pri %1!",
    #else
      "\300\236\244\333\241",
      "\333",
    #endif
    seqsize(4,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "move.pri!push.pri!load.pri %1!pop.alt!",
      "load.pri %1!",
    #else
      "\300\236\244\311\241",
      "\311",
    #endif
    seqsize(4,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "move.pri!push.pri!const.pri %1!pop.alt!",
      "const.pri %1!",
    #else
      "\300\236\244\330\241",
      "\330",
    #endif
    seqsize(4,1) - seqsize(1,1)
  },
  /* More optimizations for chained relational operators; the
   * continuation sequences can be simplified if they turn out
   * to be termination sequences:
   *    xchg                    sless       also for sless, sgeq and sleq
   *    sgrtr                   pop.alt
   *    swap.alt                and
   *    and                     ;$exp
   *    pop.alt                 -
   *    ;$exp                   -
   *    --------------------------------------
   *    xchg                    sless       also for sless, sgeq and sleq
   *    sgrtr                   pop.alt
   *    swap.alt                and
   *    and                     jzer n1
   *    pop.alt                 -
   *    jzer n1                 -
   *    --------------------------------------
   *    xchg                    jsgeq  n1   also for sless, sgeq and sleq
   *    sgrtr                   ;$exp       (occurs for non-chained comparisons)
   *    jzer n1                 -
   *    ;$exp                   -
   *    --------------------------------------
   *    xchg                    sless       also for sless, sgeq and sleq
   *    sgrtr                   ;$exp       (occurs for non-chained comparisons)
   *    ;$exp                   -
   */
  {
    #ifdef SCPACK
      "xchg!sgrtr!swap.alt!and!pop.alt!;$exp!",
      "sless!pop.alt!and!;$exp!",
    #else
      "\274\371\237swa\234\337\266\252",
      "\372\266\337!\252",
    #endif
    seqsize(5,0) - seqsize(3,0)
  },
  {
    #ifdef SCPACK
      "xchg!sless!swap.alt!and!pop.alt!;$exp!",
      "sgrtr!pop.alt!and!;$exp!",
    #else
      "\274\372!swa\234\337\266\252",
      "\371\237\241\337!\252",
    #endif
    seqsize(5,0) - seqsize(3,0)
  },
  {
    #ifdef SCPACK
      "xchg!sgeq!swap.alt!and!pop.alt!;$exp!",
      "sleq!pop.alt!and!;$exp!",
    #else
      "\274\320\325swa\234\337\266\252",
      "\321\262\266\337!\252",
    #endif
    seqsize(5,0) - seqsize(3,0)
  },
  {
    #ifdef SCPACK
      "xchg!sleq!swap.alt!and!pop.alt!;$exp!",
      "sgeq!pop.alt!and!;$exp!",
    #else
      "\274\321\325swa\234\337\266\252",
      "\320\262\266\337!\252",
    #endif
    seqsize(5,0) - seqsize(3,0)
  },
  {
    #ifdef SCPACK
      "xchg!sgrtr!swap.alt!and!pop.alt!jzer %1!",
      "sless!pop.alt!and!jzer %1!",
    #else
      "\274\371\237swa\234\337\266\323",
      "\372\266\337!\323",
    #endif
    seqsize(5,0) - seqsize(3,0)
  },
  {
    #ifdef SCPACK
      "xchg!sless!swap.alt!and!pop.alt!jzer %1!",
      "sgrtr!pop.alt!and!jzer %1!",
    #else
      "\274\372!swa\234\337\266\323",
      "\371\237\241\337!\323",
    #endif
    seqsize(5,0) - seqsize(3,0)
  },
  {
    #ifdef SCPACK
      "xchg!sgeq!swap.alt!and!pop.alt!jzer %1!",
      "sleq!pop.alt!and!jzer %1!",
    #else
      "\274\320\325swa\234\337\266\323",
      "\321\262\266\337!\323",
    #endif
    seqsize(5,0) - seqsize(3,0)
  },
  {
    #ifdef SCPACK
      "xchg!sleq!swap.alt!and!pop.alt!jzer %1!",
      "sgeq!pop.alt!and!jzer %1!",
    #else
      "\274\321\325swa\234\337\266\323",
      "\320\262\266\337!\323",
    #endif
    seqsize(5,0) - seqsize(3,0)
  },
  {
    #ifdef SCPACK
      "xchg!sgrtr!jzer %1!;$exp!",
      "jsgeq %1!;$exp!",
    #else
      "\274\371\237\303\301",
      "j\320\262\301",
    #endif
    seqsize(3,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "xchg!sless!jzer %1!;$exp!",
      "jsleq %1!;$exp!",
    #else
      "\274\372!\303\301",
      "j\321\262\301",
    #endif
    seqsize(3,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "xchg!sgeq!jzer %1!;$exp!",
      "jsgrtr %1!;$exp!",
    #else
      "\274\320\325\303\301",
      "j\371r\301",
    #endif
    seqsize(3,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "xchg!sleq!jzer %1!;$exp!",
      "jsless %1!;$exp!",
    #else
      "\274\321\325\303\301",
      "j\372\301",
    #endif
    seqsize(3,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "xchg!sgrtr!;$exp!",
      "sless!;$exp!",
    #else
      "\274\371\237\252",
      "\372!\252",
    #endif
    seqsize(2,0) - seqsize(1,0)
  },
  {
    #ifdef SCPACK
      "xchg!sless!;$exp!",
      "sgrtr!;$exp!",
    #else
      "\274\372!\252",
      "\371\237\252",
    #endif
    seqsize(2,0) - seqsize(1,0)
  },
  {
    #ifdef SCPACK
      "xchg!sgeq!;$exp!",
      "sleq!;$exp!",
    #else
      "\274\320\325\252",
      "\321\325\252",
    #endif
    seqsize(2,0) - seqsize(1,0)
  },
  {
    #ifdef SCPACK
      "xchg!sleq!;$exp!",
      "sgeq!;$exp!",
    #else
      "\274\321\325\252",
      "\320\325\252",
    #endif
    seqsize(2,0) - seqsize(1,0)
  },
  /* The entry to chained operators is also opt to optimization
   *    load.s.pri n1           load.s.pri n2
   *    load.s.alt n2           load.s.alt n1
   *    xchg                    -
   *    --------------------------------------
   *    load.s.pri n1           load.pri n2
   *    load.alt n2             load.s.alt n1
   *    xchg                    -
   *    --------------------------------------
   *    load.s.pri n1           const.pri n2
   *    const.alt n2            load.s.alt n1
   *    xchg                    -
   *    --------------------------------------
   * and all permutations...
   */
  {
    #ifdef SCPACK
      "load.s.pri %1!load.s.alt %2!xchg!",
      "load.s.pri %2!load.s.alt %1!",
    #else
      "\333\226\304\274",
      "\246\375",
    #endif
    seqsize(3,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!load.alt %2!xchg!",
      "load.pri %2!load.s.alt %1!",
    #else
      "\333\362\274",
      "\334\375",
    #endif
    seqsize(3,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!const.alt %2!xchg!",
      "const.pri %2!load.s.alt %1!",
    #else
      "\333\233\304\274",
      "\344\375",
    #endif
    seqsize(3,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "load.pri %1!load.s.alt %2!xchg!",
      "load.s.pri %2!load.alt %1!",
    #else
      "\311\226\304\274",
      "\246\374",
    #endif
    seqsize(3,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "load.pri %1!load.alt %2!xchg!",
      "load.pri %2!load.alt %1!",
    #else
      "\311\362\274",
      "\334\374",
    #endif
    seqsize(3,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "load.pri %1!const.alt %2!xchg!",
      "const.pri %2!load.alt %1!",
    #else
      "\311\233\304\274",
      "\344\374",
    #endif
    seqsize(3,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.s.alt %2!xchg!",
      "load.s.pri %2!const.alt %1!",
    #else
      "\330\226\304\274",
      "\246\356",
    #endif
    seqsize(3,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.alt %2!xchg!",
      "load.pri %2!const.alt %1!",
    #else
      "\330\362\274",
      "\334\356",
    #endif
    seqsize(3,2) - seqsize(2,2)
  },
  /* some sequences where PRI is moved to ALT can be optimized
   * further when considering what follows
   *    move.alt                const.alt n1
   *    const.pri %1            -
   *    xchg                    -
   * (also for load.s.pri and load.pri)
   *    --------------------------------------
   *    lref.pri %1             lref.alt %1
   *    move.alt                [load.pri %2]
   *    [load.pri %2]           -
   * (where [load.pri %2] may also be another operatrion loading PRI)
   */
  {
    #ifdef SCPACK
      "move.alt!const.pri %1!xchg!",
      "const.alt %1!",
    #else
      "\306\330\274",
      "\356",
    #endif
    seqsize(3,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "move.alt!load.pri %1!xchg!",
      "load.alt %1!",
    #else
      "\306\311\274",
      "\374",
    #endif
    seqsize(3,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "move.alt!load.s.pri %1!xchg!",
      "load.s.alt %1!",
    #else
      "\306\333\274",
      "\375",
    #endif
    seqsize(3,1) - seqsize(1,1)
  },
  /* ----- */
  {
    #ifdef SCPACK
      "lref.pri %1!move.alt!load.pri %2!",
      "lref.alt %1!load.pri %2!",
    #else
      "\350\225\306\334",
      "\350\243\334",
    #endif
    seqsize(3,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "lref.pri %1!move.alt!load.s.pri %2!",
      "lref.alt %1!load.s.pri %2!",
    #else
      "\350\225\306\246",
      "\350\310",
    #endif
    seqsize(3,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "lref.pri %1!move.alt!const.pri %2!",
      "lref.alt %1!const.pri %2!",
    #else
      "\350\225\306\344",
      "\350\243\344",
    #endif
    seqsize(3,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "lref.s.pri %1!move.alt!load.pri %2!",
      "lref.s.alt %1!load.pri %2!",
    #else
      "\350\222\225\306\334",
      "\350\222\243\334",
    #endif
    seqsize(3,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "lref.s.pri %1!move.alt!load.s.pri %2!",
      "lref.s.alt %1!load.s.pri %2!",
    #else
      "\350\222\225\306\246",
      "\350\222\310",
    #endif
    seqsize(3,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "lref.s.pri %1!move.alt!const.pri %2!",
      "lref.s.alt %1!const.pri %2!",
    #else
      "\350\222\225\306\344",
      "\350\222\243\344",
    #endif
    seqsize(3,2) - seqsize(2,2)
  },
  /* Array indexing can merit from special instructions.
   * Simple indexed array lookup can be optimized quite
   * a bit.
   *    addr.pri n1             addr.alt n1
   *    push.pri                load.s.pri n2
   *    load.s.pri n2           bounds n3
   *    bounds n3               lidx.b n4
   *    shl.c.pri n4            -
   *    pop.alt                 -
   *    add                     -
   *    load.i                  -
   *
   * And to prepare for storing a value in an array
   *    addr.pri n1             addr.alt n1
   *    push.pri                load.s.pri n2
   *    load.s.pri n2           bounds n3
   *    bounds n3               idxaddr.b n4
   *    shl.c.pri n4            -
   *    pop.alt                 -
   *    add                     -
   *
   * Notes (additional cases):
   * 1. instruction addr.pri can also be const.pri (for
   *    global arrays)
   * 2. the bounds instruction can be absent
   * 3. when "n4" (the shift value) is the 2 (with 32-bit cells), use the
   *    even more optimal instructions LIDX and IDDXADDR
   *
   * If the array index is more complex, one can only optimize
   * the last four instructions:
   *    shl.c.pri n1            pop.alt
   *    pop.alt                 lidx.b n1
   *    add                     -
   *    loadi                   -
   *    --------------------------------------
   *    shl.c.pri n1            pop.alt
   *    pop.alt                 idxaddr.b n1
   *    add                     -
   */
#if !defined BIT16
  /* loading from array, "cell" shifted */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri 2!pop.alt!add!load.i!",
      "addr.alt %1!load.s.pri %2!bounds %3!lidx!",
    #else
      "\364\316\370\342\355",
      "\365\316\366!",
    #endif
    seqsize(8,4) - seqsize(4,3)
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri 2!pop.alt!add!load.i!",
      "const.alt %1!load.s.pri %2!bounds %3!lidx!",
    #else
      "\363\316\370\342\355",
      "\376\316\366!",
    #endif
    seqsize(8,4) - seqsize(4,3)
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!shl.c.pri 2!pop.alt!add!load.i!",
      "addr.alt %1!load.s.pri %2!lidx!",
    #else
      "\364\370\342\355",
      "\365\366!",
    #endif
    seqsize(7,3) - seqsize(3,2)
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!shl.c.pri 2!pop.alt!add!load.i!",
      "const.alt %1!load.s.pri %2!lidx!",
    #else
      "\363\370\342\355",
      "\376\366!",
    #endif
    seqsize(7,3) - seqsize(3,2)
  },
#endif
  /* loading from array, not "cell" shifted */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri %4!pop.alt!add!load.i!",
      "addr.alt %1!load.s.pri %2!bounds %3!lidx.b %4!",
    #else
      "\364\316\327\302\341\342\355",
      "\365\316\366\367\335",
    #endif
    seqsize(8,4) - seqsize(4,4)
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri %4!pop.alt!add!load.i!",
      "const.alt %1!load.s.pri %2!bounds %3!lidx.b %4!",
    #else
      "\363\316\327\302\341\342\355",
      "\376\316\366\367\335",
    #endif
    seqsize(8,4) - seqsize(4,4)
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!shl.c.pri %3!pop.alt!add!load.i!",
      "addr.alt %1!load.s.pri %2!lidx.b %3!",
    #else
      "\364\327\256\241\271\342\355",
      "\365\366\367\256",
    #endif
    seqsize(7,3) - seqsize(3,3)
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!shl.c.pri %3!pop.alt!add!load.i!",
      "const.alt %1!load.s.pri %2!lidx.b %3!",
    #else
      "\363\327\256\241\271\342\355",
      "\376\366\367\256",
    #endif
    seqsize(7,3) - seqsize(3,3)
  },
#if !defined BIT16
  /* array index calculation for storing a value, "cell" aligned */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri 2!pop.alt!add!",
      "addr.alt %1!load.s.pri %2!bounds %3!idxaddr!",
    #else
      "\364\316\370",
      "\365\316\322\235\237",
    #endif
    seqsize(7,4) - seqsize(4,3)
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri 2!pop.alt!add!",
      "const.alt %1!load.s.pri %2!bounds %3!idxaddr!",
    #else
      "\363\316\370",
      "\376\316\322\235\237",
    #endif
    seqsize(7,4) - seqsize(4,3)
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!shl.c.pri 2!pop.alt!add!",
      "addr.alt %1!load.s.pri %2!idxaddr!",
    #else
      "\364\370",
      "\365\322\235\237",
    #endif
    seqsize(6,3) - seqsize(3,2)
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!shl.c.pri 2!pop.alt!add!",
      "const.alt %1!load.s.pri %2!idxaddr!",
    #else
      "\363\370",
      "\376\322\235\237",
    #endif
    seqsize(6,3) - seqsize(3,2)
  },
#endif
  /* array index calculation for storing a value, not "cell" packed */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri %4!pop.alt!add!",
      "addr.alt %1!load.s.pri %2!bounds %3!idxaddr.b %4!",
    #else
      "\364\316\327\302\341",
      "\365\316\322\265\367\335",
    #endif
    seqsize(7,4) - seqsize(4,4)
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri %4!pop.alt!add!",
      "const.alt %1!load.s.pri %2!bounds %3!idxaddr.b %4!",
    #else
      "\363\316\327\302\341",
      "\376\316\322\265\367\335",
    #endif
    seqsize(7,4) - seqsize(4,4)
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!shl.c.pri %3!pop.alt!add!",
      "addr.alt %1!load.s.pri %2!idxaddr.b %3!",
    #else
      "\364\327\256\241\271",
      "\365\322\265\367\256",
    #endif
    seqsize(6,3) - seqsize(3,3)
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!shl.c.pri %3!pop.alt!add!",
      "const.alt %1!load.s.pri %2!idxaddr.b %3!",
    #else
      "\363\327\256\241\271",
      "\376\322\265\367\256",
    #endif
    seqsize(6,3) - seqsize(3,3)
  },
#if !defined BIT16
  /* the shorter array indexing sequences, see above for comments */
  {
    #ifdef SCPACK
      "shl.c.pri 2!pop.alt!add!loadi!",
      "pop.alt!lidx!",
    #else
      "\370\217\355",
      "\241\366!",
    #endif
    seqsize(4,1) - seqsize(2,0)
  },
  {
    #ifdef SCPACK
      "shl.c.pri 2!pop.alt!add!",
      "pop.alt!idxaddr!",
    #else
      "\370",
      "\241\322\235\237",
    #endif
    seqsize(3,1) - seqsize(2,0)
  },
#endif
  {
    #ifdef SCPACK
      "shl.c.pri %1!pop.alt!add!loadi!",
      "pop.alt!lidx.b %1!",
    #else
      "\314\225\241\271\217\355",
      "\241\366\367\202",
    #endif
    seqsize(4,1) - seqsize(2,1)
  },
  {
    #ifdef SCPACK
      "shl.c.pri %1!pop.alt!add!",
      "pop.alt!idxaddr.b %1!",
    #else
      "\314\225\241\271",
      "\241\322\265\367\202",
    #endif
    seqsize(3,1) - seqsize(2,1)
  },
  /* For packed arrays, there is another case (packed arrays
   * do not take advantage of the LIDX or IDXADDR instructions).
   *    addr.pri n1             addr.alt n1
   *    push.pri                load.s.pri n2
   *    load.s.pri n2           bounds n3
   *    bounds n3               -
   *    pop.alt                 -
   *
   * Notes (additional cases):
   * 1. instruction addr.pri can also be const.pri (for
   *    global arrays)
   * 2. the bounds instruction can be absent, but that
   *    case is already handled (see #1#)
   */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!pop.alt!",
      "addr.alt %1!load.s.pri %2!bounds %3!",
    #else
      "\364\316\241",
      "\365\316",
    #endif
    seqsize(5,3) - seqsize(3,3)
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!pop.alt!",
      "const.alt %1!load.s.pri %2!bounds %3!",
    #else
      "\363\316\241",
      "\376\316",
    #endif
    seqsize(5,3) - seqsize(3,3)
  },
  /* Declaration of simple variables often follows the sequence:
   *    ;$lcl <name> <stk>      ;$lcl <name> <stk>
   *    stack -4                push.c <constval>
   *    const.pri <constval>    ;$exp
   *    stor.s.pri <stk>        -
   *    ;$exp                   -
   */
  {
    #ifdef SCPACK
      ";$lcl %1 %2!stack -4!const.pri %3!stor.s.pri %2!;$exp!",
      ";$lcl %1 %2!push.c %3!;$exp!",
    #else
      "\224lcl\332\227ack -4!\233\206\256\227or\222\230\252",
      "\224lcl\332\331\256\252",
    #endif
    seqsize(3,3) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      ";$lcl %1 %2!stack -4!zero.pri!stor.s.pri %2!;$exp!",
      ";$lcl %1 %2!push.c 0!;$exp!",
    #else
      "\224lcl\332\227ack -4!\373\227or\222\230\252",
      "\224lcl\332\331 0!\252",
    #endif
    seqsize(3,2) - seqsize(1,1)
  },
  /* During a calculation, the intermediate result must sometimes
   * be moved from PRI to ALT, like in:
   *    push.pri                move.alt
   *    load.s.pri n1           load.s.pri n1
   *    pop.alt                 -
   *
   * The above also accurs for "load.pri" and for "const.pri",
   * so add another two cases.
   */
  {
    #ifdef SCPACK
      "push.pri!load.s.pri %1!pop.alt!",
      "move.alt!load.s.pri %1!",
    #else
      "\244\333\241",
      "\306\333",
    #endif
    seqsize(3,1) - seqsize(2,1)
  },
  {
    #ifdef SCPACK
      "push.pri!load.pri %1!pop.alt!",
      "move.alt!load.pri %1!",
    #else
      "\244\311\241",
      "\306\311",
    #endif
    seqsize(3,1) - seqsize(2,1)
  },
  {
    #ifdef SCPACK
      "push.pri!const.pri %1!pop.alt!",
      "move.alt!const.pri %1!",
    #else
      "\244\330\241",
      "\306\330",
    #endif
    seqsize(3,1) - seqsize(2,1)
  },
  {
    #ifdef SCPACK
      "push.pri!zero.pri!pop.alt!",
      "move.alt!zero.pri!",
    #else
      "\244\373\241",
      "\306\373",
    #endif
    seqsize(3,0) - seqsize(2,0)
  },
  /* saving PRI and then loading from its address
   * occurs when indexing a multi-dimensional array
   */
  {
    #ifdef SCPACK
      "push.pri!load.i!pop.alt!",
      "move.alt!load.i!",
    #else
      "\244\342i\266",
      "\306\342\355",
    #endif
    seqsize(3,0) - seqsize(2,0)
  },
  /* An even simpler PUSH/POP optimization (occurs in
   * switch statements):
   *    push.pri                move.alt
   *    pop.alt                 -
   */
  {
    #ifdef SCPACK
      "push.pri!pop.alt!",
      "move.alt!",
    #else
      "\244\241",
      "\306",
    #endif
    seqsize(2,0) - seqsize(1,0)
  },
  /* Some simple arithmetic sequences
   */
  {
    #ifdef SCPACK
      "move.alt!load.s.pri %1!add!",
      "load.s.alt %1!add!",
    #else
      "\306\333\271",
      "\375\271",
    #endif
    seqsize(3,1) - seqsize(2,1)
  },
  {
    #ifdef SCPACK
      "move.alt!load.pri %1!add!",
      "load.alt %1!add!",
    #else
      "\306\311\271",
      "\374\271",
    #endif
    seqsize(3,1) - seqsize(2,1)
  },
  {
    #ifdef SCPACK
      "move.alt!const.pri %1!add!",
      "const.alt %1!add!",
    #else
      "\306\330\271",
      "\356\271",
    #endif
    seqsize(3,1) - seqsize(2,1)
  },
  {
    #ifdef SCPACK
      "move.alt!load.s.pri %1!sub.alt!",
      "load.s.alt %1!sub!",
    #else
      "\306\333sub\223",
      "\375sub!",
    #endif
    seqsize(3,1) - seqsize(2,1)
  },
  {
    #ifdef SCPACK
      "move.alt!load.pri %1!sub.alt!",
      "load.alt %1!sub!",
    #else
      "\306\311sub\223",
      "\374sub!",
    #endif
    seqsize(3,1) - seqsize(2,1)
  },
  {
    #ifdef SCPACK
      "move.alt!const.pri %1!sub.alt!",
      "const.alt %1!sub!",
    #else
      "\306\330sub\223",
      "\356sub!",
    #endif
    seqsize(3,1) - seqsize(2,1)
  },
  /* User-defined operators first load the operands into registers and
   * then have them pushed onto the stack. This can give rise to sequences
   * like:
   *    const.pri n1            push.c n1
   *    const.alt n2            push.c n2
   *    push.pri                -
   *    push.alt                -
   * A similar sequence occurs with the two PUSH.pri/alt instructions inverted.
   * The first, second, or both CONST.pri/alt instructions can also be
   * LOAD.pri/alt.
   * This gives 2 x 4 cases.
   */
  {
    #ifdef SCPACK
      "const.pri %1!const.alt %2!push.pri!push.alt!",
      "push.c %1!push.c %2!",
    #else
      "\330\233\304\244\354",
      "\331\202\331\221",
    #endif
    seqsize(4,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "const.pri %1!const.alt %2!push.alt!push.pri!",
      "push.c %2!push.c %1!",
    #else
      "\330\233\304\354\244",
      "\331\221\331\202",
    #endif
    seqsize(4,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.alt %2!push.pri!push.alt!",
      "push.c %1!push %2!",
    #else
      "\330\362\244\354",
      "\331\202\216\221",
    #endif
    seqsize(4,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.alt %2!push.alt!push.pri!",
      "push %2!push.c %1!",
    #else
      "\330\362\354\244",
      "\216\221\331\202",
    #endif
    seqsize(4,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "load.pri %1!const.alt %2!push.pri!push.alt!",
      "push %1!push.c %2!",
    #else
      "\311\233\304\244\354",
      "\216\202\331\221",
    #endif
    seqsize(4,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "load.pri %1!const.alt %2!push.alt!push.pri!",
      "push.c %2!push %1!",
    #else
      "\311\233\304\354\244",
      "\331\221\216\202",
    #endif
    seqsize(4,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "load.pri %1!load.alt %2!push.pri!push.alt!",
      "push %1!push %2!",
    #else
      "\311\362\244\354",
      "\216\202\216\221",
    #endif
    seqsize(4,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "load.pri %1!load.alt %2!push.alt!push.pri!",
      "push %2!push %1!",
    #else
      "\311\362\354\244",
      "\216\221\216\202",
    #endif
    seqsize(4,2) - seqsize(2,2)
  },
  /* Function calls (parameters are passed on the stack)
   *    load.s.pri n1           push.s n1
   *    push.pri                -
   *    --------------------------------------
   *    load.pri n1             push n1
   *    push.pri                -
   *    --------------------------------------
   *    const.pri n1            push.c n1
   *    push.pri                -
   *    --------------------------------------
   *    zero.pri                push.c 0
   *    push.pri                -
   *    --------------------------------------
   *    addr.pri n1             push.adr n1
   *    push.pri                -
   *
   * However, PRI must not be needed after this instruction
   * if this shortcut is used. Check for the ;$par comment.
   */
  {
    #ifdef SCPACK
      "load.s.pri %1!push.pri!;$par!",
      "push.s %1!;$par!",
    #else
      "\226\264\255",
      "\216\222\202\255",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "load.pri %1!push.pri!;$par!",
      "push %1!;$par!",
    #else
      "\217\264\255",
      "\216\202\255",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!;$par!",
      "push.c %1!;$par!",
    #else
      "\233\264\255",
      "\331\202\255",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "zero.pri!push.pri!;$par!",
      "push.c 0!;$par!",
    #else
      "\373\244\255",
      "\331 0!\255",
    #endif
    seqsize(2,0) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!;$par!",
      "push.adr %1!;$par!",
    #else
      "\265\264\255",
      "\216\326\202\255",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  /* References with a default value generate new cells on the heap
   * dynamically. That code often ends with:
   *    move.pri                push.alt
   *    push.pri                -
   */
  {
    #ifdef SCPACK
      "move.pri!push.pri!",
      "push.alt!",
    #else
      "\300\236\244",
      "\354",
    #endif
    seqsize(2,0) - seqsize(1,0)
  },
  /* Simple arithmetic operations on constants. Noteworthy is the
   * subtraction of a constant, since it is converted to the addition
   * of the inverse value.
   *    const.alt n1            add.c n1
   *    add                     -
   *    --------------------------------------
   *    const.alt n1            add.c -n1
   *    sub                     -
   *    --------------------------------------
   *    const.alt n1            smul.c n1
   *    smul                    -
   *    --------------------------------------
   *    const.alt n1            eq.c.pri n1
   *    eq                      -
   */
  {
    #ifdef SCPACK
      "const.alt %1!add!",
      "add.c %1!",
    #else
      "\356\271",
      "\235\242\202",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "const.alt %1!sub!",
      "add.c -%1!",
    #else
      "\356sub!",
      "\235\242 -\201",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "const.alt %1!smul!",
      "smul.c %1!",
    #else
      "\356smul!",
      "smu\307\202",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "const.alt %1!eq!",
      "eq.c.pri %1!",
    #else
      "\356\325",
      "\262\242\225",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  /* Some operations use the alternative subtraction operation --these
   * can also be optimized.
   *    const.pri n1            load.s.pri n2
   *    load.s.alt n2           add.c -n1
   *    sub.alt                 -
   *    --------------------------------------
   *    const.pri n1            load.pri n2
   *    load.alt n2             add.c -n1
   *    sub.alt                 -
   */
  {
    #ifdef SCPACK
      "const.pri %1!load.s.alt %2!sub.alt!",
      "load.s.pri %2!add.c -%1!",
    #else
      "\330\226\304sub\223",
      "\246\235\242 -\201",
    #endif
    seqsize(3,2) - seqsize(2,2)
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.alt %2!sub.alt!",
      "load.pri %2!add.c -%1!",
    #else
      "\330\362sub\223",
      "\334\235\242 -\201",
    #endif
    seqsize(3,2) - seqsize(2,2)
  },
  /* With arrays indexed with constants that come from enumerations, it happens
   * multiple add.c opcodes follow in sequence.
   *    add.c n1                add.c n1+n2
   *    add.c n2                -
   */
  {
    #ifdef SCPACK
      "add.c %1!add.c %2!",
      "add.c %1+%2!",
    #else
      "\235\242\202\235\242\221",
      "\235\242\267+%2!",
    #endif
    seqsize(2,2) - seqsize(1,1)
  },
  /* Compare and jump
   *    eq                      jneq n1
   *    jzer n1                 -
   *    --------------------------------------
   *    eq                      jeq n1
   *    jnz n1                  -
   *    --------------------------------------
   *    neq                     jeq n1
   *    jzer n1                 -
   *    --------------------------------------
   *    neq                     jneq n1
   *    jnz n1                  -
   * Compares followed by jzer occur much more
   * often than compares followed with jnz. So we
   * take the easy route here.
   *    less                    jgeq n1
   *    jzer n1                 -
   *    --------------------------------------
   *    leq                     jgrtr n1
   *    jzer n1                 -
   *    --------------------------------------
   *    grtr                    jleq n1
   *    jzer n1                 -
   *    --------------------------------------
   *    geq                     jless n1
   *    jzer n1                 -
   *    --------------------------------------
   *    sless                   jsgeq n1
   *    jzer n1                 -
   *    --------------------------------------
   *    sleq                    jsgrtr n1
   *    jzer n1                 -
   *    --------------------------------------
   *    sgrtr                   jsleq n1
   *    jzer n1                 -
   *    --------------------------------------
   *    sgeq                    jsless n1
   *    jzer n1                 -
   */
  {
    #ifdef SCPACK
      "eq!jzer %1!",
      "jneq %1!",
    #else
      "\325\323",
      "jn\357",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "eq!jnz %1!",
      "jeq %1!",
    #else
      "\325jnz\202",
      "j\357",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "neq!jzer %1!",
      "jeq %1!",
    #else
      "n\325\323",
      "j\357",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "neq!jnz %1!",
      "jneq %1!",
    #else
      "n\325jnz\202",
      "jn\357",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "less!jzer %1!",
      "jgeq %1!",
    #else
      "l\352!\323",
      "jg\357",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "leq!jzer %1!",
      "jgrtr %1!",
    #else
      "l\325\323",
      "jg\353r\202",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "grtr!jzer %1!",
      "jleq %1!",
    #else
      "g\353\237\323",
      "jl\357",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "geq!jzer %1!",
      "jless %1!",
    #else
      "g\325\323",
      "jl\352\202",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "sless!jzer %1!",
      "jsgeq %1!",
    #else
      "\372!\323",
      "j\320\357",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "sleq!jzer %1!",
      "jsgrtr %1!",
    #else
      "\321\325\323",
      "j\371r\202",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "sgrtr!jzer %1!",
      "jsleq %1!",
    #else
      "\371\237\323",
      "j\321\357",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "sgeq!jzer %1!",
      "jsless %1!",
    #else
      "\320\325\323",
      "j\372\202",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  /* Test for zero (common case, especially for strings)
   * E.g. the test expression of: "for (i=0; str{i}!=0; ++i)"
   *
   *    zero.alt                jzer n1
   *    jeq n1                  -
   *    --------------------------------------
   *    zero.alt                jnz n1
   *    jneq n1                 -
   */
  {
    #ifdef SCPACK
      "zero.alt!jeq %1!",
      "jzer %1!",
    #else
      "\340\223j\357",
      "\323",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "zero.alt!jneq %1!",
      "jnz %1!",
    #else
      "\340\223jn\357",
      "jnz\202",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  /* Incrementing and decrementing leaves a value in
   * in PRI which may not be used (for example, as the
   * third expression in a "for" loop).
   *    inc n1                  inc n1  ; ++n
   *    load.pri n1             ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    load.pri n1             inc n1  ; n++, e.g. "for (n=0; n<10; n++)"
   *    inc n1                  ;$exp
   *    ;$exp                   -
   * Plus the varieties for stack relative increments
   * and decrements.
   */
  {
    #ifdef SCPACK
      "inc %1!load.pri %1!;$exp!",
      "inc %1!;$exp!",
    #else
      "inc\202\311\252",
      "inc\301",
    #endif
    seqsize(2,2) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "load.pri %1!inc %1!;$exp!",
      "inc %1!;$exp!",
    #else
      "\311inc\301",
      "inc\301",
    #endif
    seqsize(2,2) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "inc.s %1!load.s.pri %1!;$exp!",
      "inc.s %1!;$exp!",
    #else
      "inc\222\202\333\252",
      "inc\222\301",
    #endif
    seqsize(2,2) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!inc.s %1!;$exp!",
      "inc.s %1!;$exp!",
    #else
      "\333inc\222\301",
      "inc\222\301",
    #endif
    seqsize(2,2) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "dec %1!load.pri %1!;$exp!",
      "dec %1!;$exp!",
    #else
      "dec\202\311\252",
      "dec\301",
    #endif
    seqsize(2,2) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "load.pri %1!dec %1!;$exp!",
      "dec %1!;$exp!",
    #else
      "\311dec\301",
      "dec\301",
    #endif
    seqsize(2,2) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "dec.s %1!load.s.pri %1!;$exp!",
      "dec.s %1!;$exp!",
    #else
      "dec\222\202\333\252",
      "dec\222\301",
    #endif
    seqsize(2,2) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!dec.s %1!;$exp!",
      "dec.s %1!;$exp!",
    #else
      "\333dec\222\301",
      "dec\222\301",
    #endif
    seqsize(2,2) - seqsize(1,1)
  },
  /* ??? the same (increments and decrements) for references */
  /* Loading the constant zero has a special opcode.
   * When storing zero in memory, the value of PRI must not be later on.
   *    const.pri 0             zero n1
   *    stor.pri n1             ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    const.pri 0             zero.s n1
   *    stor.s.pri n1           ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    zero.pri                zero n1
   *    stor.pri n1             ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    zero.pri                zero.s n1
   *    stor.s.pri n1           ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    const.pri 0             zero.pri
   *    --------------------------------------
   *    const.alt 0             zero.alt
   * The last two alternatives save more memory than they save
   * time, but anyway...
   */
  {
    #ifdef SCPACK
      "const.pri 0!stor.pri %1!;$exp!",
      "zero %1!;$exp!",
    #else
      "\233\206 0!\227or\225\252",
      "\340\301",
    #endif
    seqsize(2,2) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "const.pri 0!stor.s.pri %1!;$exp!",
      "zero.s %1!;$exp!",
    #else
      "\233\206 0!\227or\222\225\252",
      "\340\222\301",
    #endif
    seqsize(2,2) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "zero.pri!stor.pri %1!;$exp!",
      "zero %1!;$exp!",
    #else
      "\373\227or\225\252",
      "\340\301",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "zero.pri!stor.s.pri %1!;$exp!",
      "zero.s %1!;$exp!",
    #else
      "\373\227or\222\225\252",
      "\340\222\301",
    #endif
    seqsize(2,1) - seqsize(1,1)
  },
  {
    #ifdef SCPACK
      "const.pri 0!",
      "zero.pri!",
    #else
      "\233\206 0!",
      "\373",
    #endif
    seqsize(1,1) - seqsize(1,0)
  },
  {
    #ifdef SCPACK
      "const.alt 0!",
      "zero.alt!",
    #else
      "\233\212 0!",
      "\340\223",
    #endif
    seqsize(1,1) - seqsize(1,0)
  },

  /* ------------------ */
  /* Macro instructions */
  /* ------------------ */

  { "", "", 0 },    /* separator, so optimizer can stop before generating macro opcodes */

  /* optimizing the calling of native functions (which always have a parameter
   * count pushed before, and the stack pointer restored afterwards
   */
  {
    #ifdef SCPACK
      "push.c %1!sysreq.c %2!stack %3!",        //note: %3 == %1 + 4
      "sysreq.n %2 %1!",
    #else
      "\331\202sysr\262\242\221\227ack\256",
      "sysr\262.n\220\202",
    #endif
    seqsize(3,3) - seqsize(1,2)
  },
  /* ----- */
  /* Functions with many parameters with the same "type" have sequences like:
   *    push.c n1               push3.c n1 n2 n3
   *    ;$par                   ;$par
   *    push.c n2               -
   *    ;$par                   -
   *    push.c n3               -
   *    ;$par                   -
   *    etc.                    etc.
   *
   * Similar sequences occur with PUSH, PUSH.s and PUSHADDR
   */
  {
    #ifdef SCPACK
      "push.c %1!;$par!push.c %2!;$par!push.c %3!;$par!push.c %4!;$par!push.c %5!",
      "push5.c %1 %2 %3 %4 %5!",
    #else
      "\331\336\242\345\242\256\257\242\335\257\242\2035!",
      "\2165\242\343\245\302\2035!",
    #endif
    seqsize(5,5) - seqsize(1,5)
  },
  {
    #ifdef SCPACK
      "push.c %1!;$par!push.c %2!;$par!push.c %3!;$par!push.c %4!",
      "push4.c %1 %2 %3 %4!",
    #else
      "\331\336\242\345\242\256\257\242\335",
      "\2164\242\343\245\335",
    #endif
    seqsize(4,4) - seqsize(1,4)
  },
  {
    #ifdef SCPACK
      "push.c %1!;$par!push.c %2!;$par!push.c %3!",
      "push3.c %1 %2 %3!",
    #else
      "\331\336\242\345\242\256",
      "\2163\242\343\256",
    #endif
    seqsize(3,3) - seqsize(1,3)
  },
  {
    #ifdef SCPACK
      "push.c %1!;$par!push.c %2!",
      "push2.c %1 %2!",
    #else
      "\331\336\242\221",
      "\2162\242\332",
    #endif
    seqsize(2,2) - seqsize(1,2)
  },
  /* ----- */
  {
    #ifdef SCPACK
      "push %1!;$par!push %2!;$par!push %3!;$par!push %4!;$par!push %5!",
      "push5 %1 %2 %3 %4 %5!",
    #else
      "\216\336\345\256\257\335\257\2035!",
      "\2165\343\245\302\2035!",
    #endif
    seqsize(5,5) - seqsize(1,5)
  },
  {
    #ifdef SCPACK
      "push %1!;$par!push %2!;$par!push %3!;$par!push %4!",
      "push4 %1 %2 %3 %4!",
    #else
      "\216\336\345\256\257\335",
      "\2164\343\245\335",
    #endif
    seqsize(4,4) - seqsize(1,4)
  },
  {
    #ifdef SCPACK
      "push %1!;$par!push %2!;$par!push %3!",
      "push3 %1 %2 %3!",
    #else
      "\216\336\345\256",
      "\2163\343\256",
    #endif
    seqsize(3,3) - seqsize(1,3)
  },
  {
    #ifdef SCPACK
      "push %1!;$par!push %2!",
      "push2 %1 %2!",
    #else
      "\216\336\221",
      "\2162\332",
    #endif
    seqsize(2,2) - seqsize(1,2)
  },
  /* ----- */
  {
    #ifdef SCPACK
      "push.s %1!;$par!push.s %2!;$par!push.s %3!;$par!push.s %4!;$par!push.s %5!",
      "push5.s %1 %2 %3 %4 %5!",
    #else
      "\216\222\336\222\345\222\256\257\222\335\257\222\2035!",
      "\2165\222\343\245\302\2035!",
    #endif
    seqsize(5,5) - seqsize(1,5)
  },
  {
    #ifdef SCPACK
      "push.s %1!;$par!push.s %2!;$par!push.s %3!;$par!push.s %4!",
      "push4.s %1 %2 %3 %4!",
    #else
      "\216\222\336\222\345\222\256\257\222\335",
      "\2164\222\343\245\335",
    #endif
    seqsize(4,4) - seqsize(1,4)
  },
  {
    #ifdef SCPACK
      "push.s %1!;$par!push.s %2!;$par!push.s %3!",
      "push3.s %1 %2 %3!",
    #else
      "\216\222\336\222\345\222\256",
      "\2163\222\343\256",
    #endif
    seqsize(3,3) - seqsize(1,3)
  },
  {
    #ifdef SCPACK
      "push.s %1!;$par!push.s %2!",
      "push2.s %1 %2!",
    #else
      "\216\222\336\222\221",
      "\2162\222\332",
    #endif
    seqsize(2,2) - seqsize(1,2)
  },
  /* ----- */
  {
    #ifdef SCPACK
      "push.adr %1!;$par!push.adr %2!;$par!push.adr %3!;$par!push.adr %4!;$par!push.adr %5!",
      "push5.adr %1 %2 %3 %4 %5!",
    #else
      "\216\326\336\326\345\326\256\257\326\335\257\326\2035!",
      "\2165\326\343\245\302\2035!",
    #endif
    seqsize(5,5) - seqsize(1,5)
  },
  {
    #ifdef SCPACK
      "push.adr %1!;$par!push.adr %2!;$par!push.adr %3!;$par!push.adr %4!",
      "push4.adr %1 %2 %3 %4!",
    #else
      "\216\326\336\326\345\326\256\257\326\335",
      "\2164\326\343\245\335",
    #endif
    seqsize(4,4) - seqsize(1,4)
  },
  {
    #ifdef SCPACK
      "push.adr %1!;$par!push.adr %2!;$par!push.adr %3!",
      "push3.adr %1 %2 %3!",
    #else
      "\216\326\336\326\345\326\256",
      "\2163\326\343\256",
    #endif
    seqsize(3,3) - seqsize(1,3)
  },
  {
    #ifdef SCPACK
      "push.adr %1!;$par!push.adr %2!",
      "push2.adr %1 %2!",
    #else
      "\216\326\336\326\221",
      "\2162\326\332",
    #endif
    seqsize(2,2) - seqsize(1,2)
  },
  /* Loading two registers at a time
   *    load.pri n1             load.both n1 n2
   *    load.alt n2             -
   *    --------------------------------------
   *    load.alt n2             load.both n1 n2
   *    load.pri n1             -
   *    --------------------------------------
   *    load.s.pri n1           load.s.both n1 n2
   *    load.s.alt n2           -
   *    --------------------------------------
   *    load.s.alt n2           load.s.both n1 n2
   *    load.s.pri n1           -
   */
  {
    #ifdef SCPACK
      "load.pri %1!load.alt %2!",
      "load.both %1 %2!",
    #else
      "\311\362",
      "\342\275th\332",
    #endif
    seqsize(2,2) - seqsize(1,2)
  },
  {
    #ifdef SCPACK
      "load.alt %2!load.pri %1!",
      "load.both %1 %2!",
    #else
      "\362\311",
      "\342\275th\332",
    #endif
    seqsize(2,2) - seqsize(1,2)
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!load.s.alt %2!",
      "load.s.both %1 %2!",
    #else
      "\333\226\304",
      "\226.\275th\332",
    #endif
    seqsize(2,2) - seqsize(1,2)
  },
  {
    #ifdef SCPACK
      "load.s.alt %2!load.s.pri %1!",
      "load.s.both %1 %2!",
    #else
      "\226\304\333",
      "\226.\275th\332",
    #endif
    seqsize(2,2) - seqsize(1,2)
  },
  /* Loading two registers and then pushing them occurs with user operators
   *    load.both n1 n2         push2 n1 n2
   *    push.pri                -
   *    push.alt                -
   *    --------------------------------------
   *    load.s.both n1 n2       push2.s n1 n2
   *    push.pri                -
   *    push.alt                -
   */
  {
    #ifdef SCPACK
      "load.both %1 %2!push.pri!push.alt!",
      "push2 %1 %2!",
    #else
      "\342\275th\332\244\354",
      "\2162\332",
    #endif
    seqsize(3,2) - seqsize(1,2)
  },
  {
    #ifdef SCPACK
      "load.s.both %1 %2!push.pri!push.alt!",
      "push2.s %1 %2!",
    #else
      "\226.\275th\332\244\354",
      "\2162\222\332",
    #endif
    seqsize(3,2) - seqsize(1,2)
  },
  /* Load a constant in a variable
   *    const.pri n1            const n2 n1
   *    stor.pri n2             -
   *    --------------------------------------
   *    const.pri n1            const.s n2 n1
   *    stor.s.pri n2           -
   */
  {
    #ifdef SCPACK
      "const.pri %1!stor.pri %2!",
      "const %2 %1!",
    #else
      "\330\227or\230",
      "\233\220\202",
    #endif
    seqsize(2,2) - seqsize(1,2)
  },
  {
    #ifdef SCPACK
      "const.pri %1!stor.s.pri %2!",
      "const.s %2 %1!",
    #else
      "\330\227or\222\230",
      "\233\222\220\202",
    #endif
    seqsize(2,2) - seqsize(1,2)
  },
  /* ----- */
  { NULL, NULL, 0 }
};
